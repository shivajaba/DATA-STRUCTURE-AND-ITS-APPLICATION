#include<stdio.h> 
#include<unistd.h> 
#include<sys/types.h> 
#include<sys/wait.h>
int main() {
pid_t pid;
pid = fork(); 
if (pid < 0) {
perror("fork failed"); 
return 1;
}
else if (pid == 0) {
printf("Child process: executing 'ls -l'\n"); 
execl("/bin/date", "date", NULL); 
perror("execl failed");
}
else {
printf("Parent process: waiting for child to complete...\n"); 
wait(NULL);
printf("Child completed. Parent exiting.\n");
}
return 0;
}

2))#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/wait.h>
int main() {
pid_t pid1, pid2; 
int status;
pid1 = fork();
if (pid1 < 0) { 
perror("Fork failed"); 
return 1;
}
else if (pid1==0) {
printf("Child 1 (PID %d): exiting normally with code 10\n",getpid()); 
exit(10);
}
wait(&status);
if }
(WIFEXITED(status)) {
printf("Parent: Child 1 exited with code %d\n",WEXITSTATUS(status));
pid2 = fork();
if (pid2 < 0) { 
perror("Fork failed"); 
return 1;
}
else if (pid2==0) {
printf("Child 2 (PID %d): abort();
}
aborting...\n",getpid()); 
wait(&status);
if (WIFSIGNALED(status)) {
printf("Parent: Child 2 terminated by signal %d(usually 6 = 
SIGABRT)\n",WTERMSIG(status));
}
printf("Parent: Done.\n"); 
return 0;

33)) messagr
#include <stdio.h>
#include <sys/ipc.h> // For IPC (Inter-Process Communication) key functions 
#include <sys/shm.h> // For shared memory functions
int main() {
key_t key = ftok("shmfile",65);
int shmid = shmget(key, 1024, 0666 | IPC_CREAT); 
char *data = (char*) shmat(shmid, NULL, 0);
printf("Enter data to write: "); 
scanf("%s", data);
printf("Data written to shared memory.\n"); 
shmdt(data);
return 0;
}

Reserver....
#include <stdio.h>
#include <sys/ipc.h> // For IPC (Inter-Process Communication) key functions 
#include <sys/shm.h> // For shared memory functions
int main() {
key_t key = ftok("shmfile", 65);
int shmid = shmget(key, 1024, 0666);
char *data = (char*) shmat(shmid, NULL, 0); 
printf("Data read from shared memory: %s\n", data); 
shmdt(data);
shmctl(shmid, IPC_RMID, NULL); 
return 0;

consimur. ..
4

#include <stdio.h> 
#include <stdlib.h> 
#define BUFFERSIZE 10
int mutex = 1; 
int full = 0; 
int empty;
int n, item, item1; 
int buffer[BUFFERSIZE]; 
int in = 0, out = 0;
void wait(int *s) {
while (*s <= 0); // Busy wait 
(*s)--;
}
void signal(int *s) { 
(*s)++;
}
void producer() {
if ((in - out) >= n) {
printf("Cannot add item,buffer full\n"); 
return;
}
wait(&empty); 
wait(&mutex);
printf("\nEnter an item: "); 
scanf("%d",&item);
buffer[in % BUFFERSIZE] = item; 
in++;
signal(&mutex); 
signal(&full);
}
void consumer() { 
if (out >= in) {
printf("No items to consume\n"); 
return;
}
wait(&full); 
wait(&mutex);
item1 = buffer[out % BUFFERSIZE]; 
printf("\nConsumed item = %d", item1); 
out++;
signal(&mutex); 
signal(&empty);
}
int main() {
int choice;
printf("Enter the number of items scanf("%d", &n);
(n): "); 
if (n > BUFFERSIZE) {
printf("Buffer size exceeded. Max allowed is %d\n", BUFFERSIZE); 
return 1;
}
empty = n; 
while (1) {
printf("\n1. Produce\n2. Consume\n3. Exit\nEnter your choice: "); 
scanf("%d",&choice);
switch (choice) { 
case 1:
producer(); 
break;
case 2:
consumer(); 
break;
case 3:
exit(0); 
default:
printf("Invalid choice\n");
}
}
return 0;

banker 777

#include <stdio.h> 
#include <stdbool.h> 
#define MAX 10
int n, m;
int alloc[MAX][MAX], max[MAX][MAX], need[MAX][MAX], avail[MAX]; 
int finish[MAX] = {0}, safeSeq[MAX];
void inputMatrices() {
printf("Enter number of processes: "); 
scanf("%d", &n);
printf("Enter number of resource types: "); 
scanf("%d", &m);
printf("\nEnter Allocation Matrix:\n"); 
for (int i = 0; i < n; i++) {
printf("Process %d: ", i); 
for (int j = 0; j < m; j++) {
scanf("%d", &alloc[i][j]);
}
}
printf("\nEnter Maximum Matrix:\n"); 
for (int i = 0; i < n; i++) {
printf("Process %d: ", i);
for (int j = 0; j < m; j++) {
scanf("%d", &max[i][j]);
need[i][j] = max[i][j] - alloc[i][j];
}
}
printf("\nEnter Available Resources: "); 
for (int i = 0; i < m; i++) {
scanf("%d", &avail[i]);
}
}
bool isSafeState() { 
int work[MAX];
for (int i = 0; i < m; i++) { 
work[i] = avail[i];
}
int count = 0; 
while (count < n) {
bool found = false;
for (int i = 0; i < n; i++) { 
if (!finish[i]) {
bool canRun = true;
for (int j = 0; j < m; j++) { 
if (need[i][j] > work[j]) {
canRun = false; 
break;
}
}
if (canRun) {
for (int k = 0; k < m; k++) 
work[k] += alloc[i][k];
safeSeq[count++] = i; 
finish[i] = 1;
found = true;
}
}
}
if (!found)
return false;
}
return true;
}
void printResult(bool safe) { 
if (safe) {
printf("\nSystem is in a safe state.\nSafe sequence: "); 
for (int i = 0; i < n; i++)
printf("P%d ", safeSeq[i]);
printf("\n");
}
else
{
printf("\nSystem is NOT in a safe state. No safe sequence found.\n");
}
}
int main() {
inputMatrices();
bool safe = isSafeState(); 
printResult(safe);
return 0;
}

